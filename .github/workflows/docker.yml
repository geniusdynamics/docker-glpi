name: Sync Last 10 GLPI Images

on:
  schedule:
    - cron: "0 3 * * *" # Run daily at 3 AM UTC
  workflow_dispatch:
  push:
    branches: [master]

permissions:
  contents: write # Required for creating releases and fetching content
  packages: write # Required for pushing to GitHub Container Registry

jobs:
  fetch-tags:
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.get_tags.outputs.tags }}
    steps:
      - name: Fetch last 10 GLPI releases (stable + prerelease)
        id: get_tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API_URL="https://api.github.com/repos/glpi-project/glpi/releases?per_page=20"
          HEADERS=(-H "Accept: application/vnd.github+json" \
                   -H "Authorization: Bearer $GH_TOKEN")

          # Fetch releases, ensure curl exits with 0 and jq processes correctly
          RELEASES=$(curl -sL "${HEADERS[@]}" "$API_URL" | jq -c '.')
          if [ $? -ne 0 ]; then
            echo "Error fetching releases from GitHub API."
            exit 1
          fi

          # Extract and filter the last 10 tags
          # Ensure tags are unique and valid, then convert to a JSON array
          TAGS=$(echo "$RELEASES" | jq -r '.[0:10] | .[]?.tag_name | select(. != null)' | sort -rV | uniq)

          if [ -z "$TAGS" ]; then
            echo "No GLPI tags found or processed."
            echo "tags=[]" >> $GITHUB_OUTPUT
          else
            echo "Found GLPI releases (last 10):"
            echo "$TAGS"
            # Convert newline-separated tags to a proper JSON array for `fromJson`
            TAGS_JSON=$(echo "$TAGS" | jq -R . | jq -s .)
            echo "tags=$TAGS_JSON" >> $GITHUB_OUTPUT
          fi

  build:
    needs: fetch-tags
    # Only run if tags were successfully fetched and the array is not empty
    if: needs.fetch-tags.outputs.tags != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Allow other matrix jobs to complete even if one fails
      matrix:
        tag: ${{ fromJson(needs.fetch-tags.outputs.tags) }}

    env:
      # Use `github.repository_owner` directly for GHCR, no need for separate secret checks if you use GITHUB_TOKEN or a PAT
      DOCKER_HUB_USERNAME_SET: ${{ secrets.DOCKER_HUB_USERNAME != '' }}
      DOCKER_HUB_ACCESS_TOKEN_SET: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN != '' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Get Release Info
        id: release_info
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          API_URL="https://api.github.com/repos/glpi-project/glpi/releases/tags/${{ matrix.tag }}"
          HEADERS=(-H "Accept: application/vnd.github+json" -H "Authorization: Bearer $GH_TOKEN")

          DATA=$(curl -sL "${HEADERS[@]}" "$API_URL")
          if [ $? -ne 0 ] || [ -z "$DATA" ]; then
            echo "Error fetching release info for tag ${{ matrix.tag }}."
            exit 1
          fi

          NOTES=$(echo "$DATA" | jq -r .body)
          IS_PRERELEASE=$(echo "$DATA" | jq -r .prerelease)

          # Use sed for robust version extraction
          IMAGE_TAG_VERSION="$(echo "${{ matrix.tag }}" | sed -E 's/^v//; s/\.0$//')" # drop leading v, and trailing .0 if it's a major version (e.g. 10.0 -> 10)
          MAJOR_TAG="$(echo "$IMAGE_TAG_VERSION" | cut -d. -f1)"

          echo "IMAGE_TAG_VERSION=$IMAGE_TAG_VERSION" >> $GITHUB_ENV
          echo "MAJOR_TAG=$MAJOR_TAG" >> $GITHUB_ENV
          echo "IS_PRERELEASE=$IS_PRERELEASE" >> $GITHUB_ENV

          # Create release_notes.md, ensuring content exists
          if [ -n "$NOTES" ]; then
            echo "$NOTES" > release_notes.md
          else
            echo "No release notes found for ${{ matrix.tag }}" > release_notes.md
          fi

      - name: Check if release already exists in this repo
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # The `gh` CLI tool requires the `contents: write` permission for listing releases
          # and also relies on `GITHUB_TOKEN` being available.
          if gh release view "${{ matrix.tag }}" >/dev/null 2>&1; then
            echo "Release ${{ matrix.tag }} already exists, skipping build."
            echo "skip_build=true" >> $GITHUB_ENV
          else
            echo "skip_build=false" >> $GITHUB_ENV
          fi

      - name: Create GitHub Release
        if: env.skip_build == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Ensure release_notes.md exists before trying to use it
          if [ ! -f release_notes.md ]; then
            echo "No release notes file found, creating a basic one."
            echo "GLPI ${{ matrix.tag }}" > release_notes.md
          fi

          if [ "${{ env.IS_PRERELEASE }}" = "true" ]; then
            echo "Creating pre-release for ${{ matrix.tag }}"
            gh release create "${{ matrix.tag }}" \
              --title "GLPI ${{ matrix.tag }}" \
              --notes-file release_notes.md \
              --prerelease
          else
            echo "Creating stable release for ${{ matrix.tag }}"
            gh release create "${{ matrix.tag }}" \
              --title "GLPI ${{ matrix.tag }}" \
              --notes-file release_notes.md
          fi

      - name: Set up Docker Buildx
        if: env.skip_build == 'false'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: env.skip_build == 'false' && env.DOCKER_HUB_USERNAME_SET == 'true' && env.DOCKER_HUB_ACCESS_TOKEN_SET == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}

      - name: Log in to GitHub Container Registry
        # You can often use GITHUB_TOKEN with ${{ github.actor }} for GHCR
        # If using a separate PAT, ensure it has `write:packages` scope.
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }} # Uses the workflow actor for GHCR
          password: ${{ secrets.GITHUB_TOKEN }} # GITHUB_TOKEN has `packages: write` permission

      - name: Prepare Docker Tags
        if: env.skip_build == 'false'
        id: prep_tags
        run: |
          TAG=${{ env.IMAGE_TAG_VERSION }}
          MAJOR=${{ env.MAJOR_TAG }}
          IMAGE_DH=geniusdynamics/glpi
          IMAGE_GH=ghcr.io/${{ github.repository_owner }}/glpi

          # Initialize with an empty string, then append tags.
          # docker/build-push-action expects comma-separated tags without leading/trailing commas.
          declare -a DOCKER_TAGS=()

          # Add base tags for both registries
          DOCKER_TAGS+=("$IMAGE_DH:$TAG")
          DOCKER_TAGS+=("$IMAGE_GH:$TAG")

          if [[ "$TAG" == *"rc"* || "${{ env.IS_PRERELEASE }}" == "true" ]]; then
            # Pre-release RC tagging
            DOCKER_TAGS+=("$IMAGE_DH:${MAJOR}-rc")
            DOCKER_TAGS+=("$IMAGE_DH:rc")
            DOCKER_TAGS+=("$IMAGE_GH:${MAJOR}-rc")
            DOCKER_TAGS+=("$IMAGE_GH:rc")
          else
            # Stable release tagging
            DOCKER_TAGS+=("$IMAGE_DH:$MAJOR")
            DOCKER_TAGS+=("$IMAGE_DH:latest")
            DOCKER_TAGS+=("$IMAGE_GH:$MAJOR")
            DOCKER_TAGS+=("$IMAGE_GH:latest")
          fi

          # Join array elements with a comma
          FINAL_TAGS=$(IFS=,; echo "${DOCKER_TAGS[*]}")
          echo "Generated Docker Tags: $FINAL_TAGS"
          echo "FINAL_TAGS=$FINAL_TAGS" >> $GITHUB_ENV

      - name: Build and Push Image
        if: env.skip_build == 'false' && env.FINAL_TAGS != ''
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: ${{ env.FINAL_TAGS }}
          platforms: linux/amd64,linux/arm64 # Consider multi-arch builds if your Dockerfile supports it

      - name: Build Summary
        if: env.skip_build == 'false'
        run: |
          echo "✔️ Successfully built and pushed GLPI ${{ matrix.tag }}"
          echo "Tags: ${{ env.FINAL_TAGS }}"
